# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

find_cpp <- function(xptr, words) {
    .Call(`_kgrams_find_cpp`, xptr, words)
}

length_kgrams_dictionary <- function(xptr) {
    .Call(`_kgrams_length_kgrams_dictionary`, xptr)
}

#' Text preprocessing
#'
#' A minimal text preprocessing utility.
#'
#' @author Valerio Gherardi
#' @md
#'
#' @param input a character vector.
#' @param erase a length one character vector. Regular expression matching 
#' parts of text to be \emph{erased} from input. The default removes anything 
#' not  alphanumeric (\code{[A-z0-9]}), space (white space, tab, 
#' vertical tab, newline, form feed, carriage return), apostrophes or 
#' punctuation characters (\code{"[.?!:;]"}).
#' @param lower_case a length one logical vector. If TRUE, puts everything to 
#' lower case.
#' @return a character vector containing the processed output.
#' @details 
#' The expressions \code{preprocess(x, erase = pattern, lower_case = TRUE)} and
#' \code{preprocess(x, erase = pattern, lower_case = FALSE)} are roughly
#' equivalent to \code{tolower(gsub(pattern, "", x))} and 
#' \code{gsub(pattern, "", x)}, respectively, provided that the regular 
#' expression 'pattern' is correctly recognized by R.
#' 
#' Internally, \code{preprocess()} the string 'pattern' is converted into a C++ 
#' \code{std::regex} class by the default constructor 
#' \code{std::regex::regex(std::string)}.
#' @examples
#' preprocess("#This Is An Example@-@!#")
#' @export
preprocess <- function(input, erase = "[^.?!:;'[:alnum:][:space:]]", lower_case = TRUE) {
    .Call(`_kgrams_preprocess`, input, erase, lower_case)
}

#' Sentence tokenizer
#'
#' Extract sentences from a batch of text lines.
#'
#' @export
#'
#' @author Valerio Gherardi
#' @md
#'
#' @param input a character vector.
#' @param EOS a regular expression matching an End-Of-Sentence delimiter.
#' @param keep_first TRUE or FALSE? Should the first character of the matches
#' be appended to the returned sentences (with a space)?
#' @return a character vector, each entry of which corresponds to a single
#' sentence.
#' @details
#' \code{tokenize_sentences()} splits text into sentences using a list of 
#' single character delimiters, specified by the parameter \code{EOS}. 
#' Specifically, when an EOS token is found, the next sentence begins at the
#' first position in the input string not containing any of the EOS tokens 
#' \emph{or white space} (so that entries like \code{"Hi there!!!"} or 
#' \code{"Hello . . ."} are both recognized as a single sentence).
#' 
#' If \code{keep_first} is \code{FALSE}, the delimiters are stripped off from 
#' the returned sequences, which means that all delimiters are treated 
#' symmetrically.
#' 
#' In the absence of any \code{EOS} delimiter, \code{tokenize_sentences()} 
#' returns the input as is, since parts of text corresponding to different 
#' entries of the \code{input} vector are understood as parts of separate 
#' sentences.
#' @examples
#' tokenize_sentences("Hi there! I'm using `sbo`.")
tokenize_sentences <- function(input, EOS = "[.?!:;]+", keep_first = FALSE) {
    .Call(`_kgrams_tokenize_sentences`, input, EOS, keep_first)
}

